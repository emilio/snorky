{% extends "base.html" %}
{% load staticfiles %}{% load pygmentize_tags %}
{% block content %}

<div class="jumbotron">
  <h1>Own your data, in real time!</h1>
  <p>Synchronize your web views with remote databases and more.</p>
  <p class="license"><a onclick="ga('send', 'event', 'License', 'Jumbotron')"
    href="https://www.mozilla.org/MPL/2.0/">MPL 2.0 Licensed</a></p>
  <a class="button" onclick="ga('send', 'event', 'Download', 'Jumbotron')"
    href="https://github.com/ntrrgc/snorky/archive/v{{ version }}.tar.gz">Download version {{ version }}</a>
  <a class="button" onclick="ga('send', 'event', 'GitHub', 'Jumbotron')"
    href="https://github.com/ntrrgc/snorky">Check in GitHub</a>
</div>

<div class="showcase">
<div class="showcase-text">
<h2>Write WebSocket services more easily!</h2>

<p>Snorky adds a thin layer above WebSocket that allows each server to offer different <strong><em>services</em></strong>. A built-in JSON-based RPC-like interface helps you doing more with less code.</p>

<p>Snorky uses <strong>Python</strong>, a succint language widely used in web development.</p>
</div>

<div class="showcase-picture">
  {% pygmentize "python" %}
class MyChatService(RPCService):
    def __init__(self, name):
        super().__init__(name)
        self.clients = set()

    @rpc_command
    def join(self, req):
        self.clients.add(req.client)

    @rpc_command
    def send_message(self, req, body):
        for client in self.clients:
            self.send_message_to(client, {
                "type": "chatMessage",
                "body": body
            })

    def client_disconnected(self, client):
        self.clients.remove(client){% endpygmentize %}
</div>
</div>

<div class="showcase">
<div class="showcase-text">
<h2>Replaceable protocols</h2>

<p>Snorky components are designed to be replaceable. Therefore, although WebSocket is the most frequent protocol, you can add more without touching a line of code of the services.</p>

<p>There are three protocols built-in: <strong>WebSocket</strong>, <strong>SockJS</strong> &mdash; an alternative protocol that provides fallback real-time channels for old browsers which do not support WebSocket, and <strong>HTTP</strong> &mdash; a simple API to interact with your services from other nodes of your system.</p>
</div>

<div class="showcase-picture"><img src="{% static 'img/protocols.png' %}"></div>
</div>

<div class="showcase">
<div class="showcase-text">
<h2>Wire up a backend</h2>

<p>You don&#39;t have to expose the same interface for outsiders that you expose for other servers in your datacenter. Snorky can listen on several ports and different protocols, exposing potentially different services in each case.</p>

<p>A common pattern is to feed data from a trusted server, which connects to Snorky through a <strong><em>backend channel</em></strong> (usually over HTTP), to all your users around the world which are connected through a <strong><em>frontend channel</em></strong> (usually over WebSocket).</p>
</div>

<div class="showcase-picture"><img src="{% static 'img/backend2.png' %}"></div>
</div>

<div class="datasync">
<h1>Enjoy DataSync</h1>

<p>Snorky DataSync is a Snorky service that allows your web users to receive <strong>notifications of events that occur in your database</strong>.</p>

<p>DataSync does not force you to use a specific database software or to host your data in third party servers.</p>

<a class="button" href="https://try.snorkyproject.org/" target="_blank">Try it live!</a>

</div>

<div class="showcase">
<div class="showcase-text">
<h2>Notify Snorky</h2>

<p>In order to use DataSync, you have to make sure each time a change occurs in your database, <strong>whatever your database is</strong> &mdash; Snorky does not care whether you are using a relational SQL database, a MongoDB instance or plain text files, the application sends a notification to Snorky DataSyncBackend.</p>

<p>This notification shall specify whether the change is an insertion, update or deletion and the data before and after the change. That&#39;s all.</p>
</div>
<div class="showcase-picture">
  {% pygmentize "python" %}
def create(self):
    # Insert
    cursor = get_db().cursor()
    cursor.execute('''
    INSERT INTO Players (id, name, color)
    VALUES (:id, :name, :color)''',
    self._data)

    self.id = cursor.lastrowid
    get_db().commit()

    # First commit, then notify.
    snorky_backend.publish_deltas([{
        'type': 'insert',
        'model': 'Player',
        'data': self._data,
    }]){% endpygmentize %}
</div>
</div>


<div class="showcase">
<div class="showcase-text">
<h2>Authorize subscriptions</h2>

<p>In order for clients to receive notifications from Snorky, they need a <em><strong>subscription</strong></em><strong>.</strong> Subscriptions must be authorized by the server side.</p>

<p>Usually clients request both data and a subscription at the same time. Snorky has an idiom for this in REST APIs: the <strong><em>X-Snorky</em></strong> and <strong><em>X-Subscription-Token</em></strong> headers.</p>
</div>

<div class="showcase-picture">
<div class="codehilite"><pre>
<span class="">&gt; GET /api/tasks
&gt; Accept: application/json
&gt; X-Snorky: Subscribe</span>

<span class="nt">&lt; 200 OK
&lt; Content-Type: application/json
&lt; X-Subscription-Token: oirvarwptrk7wgz7sv</span>

<span class="p">[{</span>
  <span class="s">"id"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="s">"title"</span><span class="p">:</span> <span class="s">"Learn Snorky"</span><span class="p">,</span>
  <span class="s">"completed"</span><span class="p">:</span> <span class="n">true</span>
<span class="p">}]</span>
</pre></div>
</div>
</div>

<div class="showcase">
<div class="showcase-text">
<h2>Handle events</h2>

<p>Once you&#39;ve got a subscription token, you can pass it to the Snorky Javascript library, which will <strong>trigger an event for each notification</strong> you are subscribed to.</p>

<p>In response to these events you may do whatever you want: reload the page, insert the new data with jQuery transformations, show notifications on the screen or take the approach of the following point.</p>
</div>

<div class="showcase-picture">
  <img src="{% static "img/notification.png" %}">
</div>
</div>

<div class="showcase">
<div class="showcase-text">
<h2>Leverage Distributed MVC</h2>

<p>Many Javascript libraries provide client-side templating, allowing you to put your data models in JS code and separately write templates that are rendered into HTML code by the browser. <a href="https://angularjs.org/">AngularJS</a> and <a href="http://knockoutjs.com/">Knockout</a> are popular examples, but there are many.</p>

<p>Snorky provides handy JS adapters that you can plug to these libraries in order to <strong>update your client-side models automatically</strong>. This means you can write HTML template code for a list of elements and every time a new element comes into existance it will appear instantly without waits or reloads.</p>
</div>

<div class="showcase-picture">
  <img src="{% static "img/angular.png" %}">
</div>
</div>

<div class="footer">
  <a id="email-link">Juan Luis Boya</a> &copy; 2014
</div>

{% endblock content %}
